# 내 코드
```py
want = int(input())
m, n = map(int, input().split())
piza_m = [0] * m
piza_n = [0] * n
for i in range(m):
    piza_m[i] =int(input()) # [2, 2, 1, 7, 2]
for j in range(n):
    piza_n[j] = int(input()) # [6, 8, 3]

result = 0
for slice_m in range(m):
    tmp = want
    for next_m in range(slice_m, slice_m + m):
        tmp -= piza_m[next_m % m]
        if tmp < 0:
            break
        elif tmp == 0:
            result += 1
            break
        else:
            for slice_n in range(n):
                ttmp = tmp
                for next_n in range(slice_n, slice_n + n):
                    ttmp -= piza_n[next_n % n]
                    if ttmp < 0:
                        break    
                    elif ttmp == 0:
                        result += 1
                        break
print(result)
```
-> O(N^4) 시간복잡도 어마어마....다른 방안?
# 다른 사람 풀이
## 첫 번째 방법

각각 양쪽 피자판에서 연속합으로 구할 수 있는 크기를 모두 구했다. 
피자판은 둥글기 때문에 시작점이 i에 위치해있다고 하더라도 한 바퀴 돌아서 연속합을 만들 수 있다. 즉, i-1번째 조각만 제외한 연속합을 만들 수 있다. 따라서 이 부분에서도 O(N^2)의 시간이 지나게 된다.
 

이렇게 각각 구한 연속합을 크기순으로 정렬하고 투 포인터 알고리즘을 이용했다. 하나의 피자판에서는 작은 연속합부터, 반대쪽 피자판에서는 큰 연속 합부터 인덱싱 해나 가면서 요구하는 크기와 일치하는 두 연속 합의 합의 개수를 구했다.
포인터를 이용해주었기 때문에 현재의 값과 일치하는 값의 개수 또한 반복문을 통해서 카운트해주었다.
 

이 코드는 Python에서는 통과하지 못했고, PyPy에서만 통과했다. 그것도, 목표양보다 많은 양일 경우 continue를 해주는 코드를 삽입해서 필요 없는 부분을 더 제외시켜줌으로써 겨우 통과했다. continue를 추가하기 전에는 PyPy도 시간 초과가 발생했다.
출처: https://suri78.tistory.com/170 [공부노트:티스토리]
```py
import sys

target = int(sys.stdin.readline().rstrip())
m, n = map(int, sys.stdin.readline().split())
left = [int(sys.stdin.readline().rstrip()) for _ in range(m)]
right = [int(sys.stdin.readline().rstrip()) for _ in range(n)]

lsum, rsum = [0, sum(left)], [0, sum(right)]
for i in range(m):
    for j in range(m):
        if i == j:
            continue
        elif i < j <= m:
            tmp = sum(left[i:j])
            if tmp > target:
                continue
            lsum.append(tmp)
        else: # j < i
            tmp = sum(left[i:] + left[:j])
            if tmp > target:
                continue
            lsum.append(tmp)
for i in range(n):
    for j in range(n):
        if i == j:
            continue
        elif i < j <= n:
            tmp = sum(right[i:j])
            if tmp > target:
                continue
            rsum.append(tmp)
        else: # j < i
            tmp = sum(right[i:] + right[:j])
            if tmp > target:
                continue
            rsum.append(tmp)
lsum.sort()
rsum.sort()

ans = 0
lleft, lright = len(lsum), len(rsum)
lp, rp = 0, lright-1
while lp < lleft and rp >= 0:
    tmp = lsum[lp] + rsum[rp]

    if tmp == target:
        lcnt, rcnt = 0, 0
        origin = lsum[lp]
        while lp < lleft and origin == lsum[lp]:
            lcnt += 1
            lp += 1
        origin = rsum[rp]
        while rp >= 0 and origin == rsum[rp]:
            rcnt += 1
            rp -= 1

        ans += (lcnt * rcnt)

    elif tmp < target:
        lp += 1
    else: #tmp > target
        rp -= 1

print(ans)
```
### 그래도 pypy에서라도 통과가능했던 이유...
일단 핵심부터 말하면,

- 통과한 코드 = “A 조각 경우의 수” + “B 조각 경우의 수”를 따로 구한 뒤 → 한 번만 합치는 방식 (대략 O(m² + n²))
- 너 코드 = “A 조각 경우의 수” 하나 만들 때마다 그때그때 “B 조각 모든 경우의 수”를 다시 탐색 (대략 O(m²·n²))
#### 1. 통과한 코드의 구조 (lsum/rsum 코드)
이 코드는 크게 3단계야.

(1) A 피자에서 만들 수 있는 모든 연속합을 lsum에 저장
```py
lsum = [0, sum(left)]
for i in range(m):
    for j in range(m):
        ...
        lsum.append(tmp)
```
- i, j 두 포인터로 시작점·끝점 조합을 돌면서,
- 그 구간의 합(원형까지 고려)을 한 번씩만 lsum에 넣어.
- 이중 for라서 조합 개수는 대략 m² 개.

-> n도 똑같이!!<br>
-> 이 부분의 이론상 복잡도는
O(m²) (조합 수) × O(m) (구간 길이 만큼 sum) = O(m³)라서 사실 아주 깔끔한 풀이는 아니고,
BOJ 데이터 + PyPy 특성 + tmp > target 가지치기 덕에 운 좋게 통과했을 가능성이 큼.
그래도 중요한 건 한 번 A 다 계산 → 한 번 B 다 계산한다는 구조야.

#### (2) lsum, rsum 정렬
대략 O(m² log m² + n² log n²).

#### (3) 투 포인터로 “합이 target 되는 쌍” 세기
```py
lp, rp = 0, len(rsum)-1
while lp < len(lsum) and rp >= 0:
    tmp = lsum[lp] + rsum[rp]
    ...
```
### 개념 차이 정리

✅ 정답 코드 아이디어

- A로 만들 수 있는 합들을 “전부 한 번에” 구해놓고,

- B로 만들 수 있는 합들도 “전부 한 번에” 구해놓은 뒤,

- “합이 want가 되도록” 두 리스트를 조합해서 세기 (투 포인터 or 해시)

❌ 너 코드 아이디어

- “A에서 조각 일부 고름” → 이때마다 “남은 크기를 만들 수 있는 B의 경우의 수”를 B 전체를 다시 돌면서 일일이 찾기
- 즉, A의 경우의 수 × B의 모든 경우의 수를 중첩 루프로 직접 탐색

## 두 번째 방법

- 부분합을 다 저장해 두고, 마지막에 A+B를 곱셈으로 한 번에 세기
```py
import sys

target = int(sys.stdin.readline().rstrip())
m, n = map(int, sys.stdin.readline().split())
left = [int(sys.stdin.readline().rstrip()) for _ in range(m)]
right = [int(sys.stdin.readline().rstrip()) for _ in range(n)]

lsum, rsum = [0]*2000001, [0]*2000001
lsum[0] = rsum[0] = 1
llen, rlen = len(left), len(right)
for i in range(llen):
    s = 0
    for j in range(llen):
        s += left[(i+j)%m]
        if s > target:
            break
        else:
            lsum[s] += 1
for i in range(rlen):
    s = 0
    for j in range(rlen):
        s += right[(i+j)%n]
        if s > target:
            break
        else:
            rsum[s] += 1
lsum[sum(left)] = rsum[sum(right)] = 1

ans = 0
for i in range(target+1):
    ans += (lsum[i] * rsum[target-i])
print(ans)
```
### 1. lsum / rsum 배열의 의미
```py
lsum, rsum = [0]*2000001, [0]*2000001
lsum[0] = rsum[0] = 1
```
- lsum[x] = 피자 A만으로 합이 x가 되게 고를 수 있는 방법의 수
- rsum[x] = 피자 B만으로 합이 x가 되게 고를 수 있는 방법의 수

여기서 lsum[0] = 1, rsum[0] = 1 은
- “A 피자를 0조각도 안 쓰는 방법 1가지”
- “B 피자를 0조각도 안 쓰는 방법 1가지”
를 의미해.<br>
→ 이렇게 해 두어야 A만 쓰는 경우, B만 쓰는 경우, 둘 다 쓰는 경우를 모두 자연스럽게 세어줄 수 있어.

예를 들어,
- A에서 합이 7, B에서 합이 0 → 7을 만드는 방법 1가지
- A에서 합이 4, B에서 합이 3 → 7을 만드는 방법 1가지
- A에서 합이 0, B에서 합이 7 → 7을 만드는 방법 1가지
등등.

### 2. 원형 피자에서 나올 수 있는 모든 연속합 카운트하기
#### A 피자 쪽
```py
llen = len(left)
for i in range(llen):
    s = 0
    for j in range(llen):
        s += left[(i+j)%m]
        if s > target:
            break
        else:
            lsum[s] += 1
```
여기 아이디어:
- 시작 인덱스 i를 0 ~ m-1까지 돌면서,
- j를 0 ~ m-1까지 늘려가며 s에 계속 더함
→ left[(i+j) % m]를 쓰니까 원형(도넛 모양) 피자가 자연스럽게 표현됨.
- 즉,
    - 시작점 i에서 한 조각,
    - 두 조각,
    - 세 조각, …
        이렇게 연속된 조각들을 확장해 나가며 합 s를 만든다.

### 3. “전체 피자를 한 바퀴 다 쓰는 경우” 처리
```py
lsum[sum(left)] = rsum[sum(right)] = 1
```
여기가 미묘하지만 중요한 포인트.

위의 이중 for에서
- i = 0일 때, j를 0 ~ m-1까지 더하면 → 합 = sum(left)
- i = 1일 때도, 한 바퀴 돌면 역시 합 = sum(left)
- …
- 그래서 “전체 피자를 한 바퀴 쓰는 경우”가 시작점에 따라 m번 중복 카운트될 수 있어.

하지만 문제에서 "원형 전체 한 판"은 어디서 자르든 같은 경우로 봐야 해서,
이를 딱 1번만 인정해 주려고 강제로 덮어씌운 거야.

### 4. A와 B를 합쳐서 target 만드는 경우의 수 계산
```py
ans = 0
for i in range(target+1):
    ans += (lsum[i] * rsum[target-i])
print(ans)
```
### 5. 한 줄 요약
이 풀이는
1. 원형 피자에서 만들 수 있는 “연속 부분합”을 전부 세서,
그 합별로 “경우의 수 카운트 배열(lsum, rsum)”을 만든 뒤,
2. A와 B의 합이 target이 되도록 “lsum[i] × rsum[target-i]”를 다 더하는
일종의 ‘합성곱(convolution)’ 같은 방식으로 해결하는 아이디어야.

네가 앞에서 짰던 코드는
“각 A 조합마다 B 전체를 다시 brute-force로 돌아보는” 구조라 O(m²·n²) 느낌이었고,
이 코드는
“A 전체 경우 수 O(m²) + B 전체 경우 수 O(n²) + 마지막 합치기 O(target)”로 훨씬 싸게 계산하는 구조인 것.

원하면, 이 아이디어를 기반으로 네 스타일(리스트 + 투포인터 / 딕셔너리)로 푸는 버전도 같이 리팩터링해 줄까?

## 생각할 아이디어!!
중첩루프가 나오면 스스로에게 물어봐:

>“지금 이중/삼중 for가
사실은 독립적인 두 축의 조합을 세고 있는 건 아닐까?”

- 만약 A쪽 경우의 수랑 B쪽 경우의 수가 서로 독립이라면,
- 굳이 이중 루프로 하나씩 다 돌지 말고,

→ A 쪽 경우의 수를 미리 다 세어두고<br>
→ B 쪽 경우의 수도 미리 다 세어두고<br>
→ ans += (A_count[x] * B_count[y]) 형태의 곱셈으로 한 번에 세는 쪽을 생각해볼 수 있어.